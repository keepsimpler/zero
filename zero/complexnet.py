
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: ../complexnet.ipynb

def niche(s:int, c:int, flip_diag:bool=True):
    """Niche Model for Food Web
    Args:
    - s: number of species in the community
    - c: the connectance, or fraction of realized links in the food web

    Return a numpy matrix for a niche model food web.
    a weakly connected DAG (Directed Acyclic Graph)
    """
    weakly_connected = False
    while not weakly_connected:
        b = 1 / (2 * c) - 1
        ni = sorted(np.random.uniform(size = s))
        ri = np.random.beta(a = 1, b = b, size = s) * ni
        ci = np.random.uniform(size = s, low = ri / 2, high = np.minimum(ni, 1 - ri / 2))
        A = np.zeros((s,s))
        for i in range(s):
            for j in range(i+1, s): # 1
                if ni[i] > ci[j] - .5 * ri[j] and ni[i] < ci[j] + .5 * ri[j]:
                    A[i,j] = 1
        if flip_diag:
            A = np.flip(np.rot90(A), axis=1) # rotate 90 degree anti-clockly, then flip along column
        G=nx.from_numpy_matrix(A, create_using=nx.DiGraph())
        weakly_connected = nx.is_weakly_connected(G)
    G.graph['s'] = s
    G.graph['c'] = c
    return A, G


"Add unique input node and output node for DAG"
def after_DAG(G):
    n = G.graph['s'] # number of nodes

    # find all input nodes and output nodes
    in_nodes = [v for v, d in G.in_degree() if d==0]
    out_nodes = [v for v, d in G.out_degree() if d==0]
    # number of input nodes, number of output nodes, length of longest path
    len(in_nodes), len(out_nodes), nx.dag.dag_longest_path_length(G)

    # add a node with id: -1 as the unique input node
    in_edges = [(-1,i) for i in in_nodes]
    G.add_edges_from(in_edges)
    # add a node with id: n as the unique output node
    out_edges = [(i, n) for i in out_nodes]
    G.add_edges_from(out_edges)

    return G

class NodeOP(nn.Module):
    """
    The Operation of every inner node in the network.

    Parameters:
    -----------
    Unit : the operation at the node
    kwargs : arguments to Unit
    """
    def __init__(self, ni:int, no:int, nh:int, Unit:nn.Module, **kwargs):
        super(NodeOP, self).__init__()
        self.unit = Unit(ni, no, nh, **kwargs)

    def forward(self, *inputs):
        sum_inputs = sum(inputs)
        out = self.unit(sum_inputs)
        return out


class NetworkOP(nn.Module):
    """
    The operations along a DAG network.

    Parameters:
    -----------
    G   :  the `NetworkX` 'DiGraph' object, represent a DAG.
    ni  :  number of input channels of the network
    no  :  number of output channel of the network
    Unit : operation at every inner node
    stride : if downsample
    kwargs : arguments to Unit

    """
    def __init__(self, G:nx.DiGraph, ni:int, no:int, Unit:nn.Module, stride:int=1, **kwargs):
        super(NetworkOP, self).__init__()
        self.G = G
        self.n = G.graph['s'] # number of nodes
        self.nodeop = nn.ModuleList()
        for id in G.nodes(): # for each node
            if id == -1:  # if is the unique input node, do nothing
                continue
            elif id == self.n:  # if is the unique output node
                # then, concat its predecessors
                n_preds = len([*G.predecessors(id)])
                self.nodeop += [IdentityMapping(n_preds * ni, no, stride=stride)]
            else:  # if is the inner node
                self.nodeop += [NodeOP(ni, ni, ni, Unit, **kwargs)]

    def forward(self, x):
        results = {}
        results[-1] = x  # input data is the result of the unique input node
        for id in self.G.nodes():
            if id == -1:  #
                continue
            inputs = [results[pred]  for pred in self.G.predecessors(id)]
            if id == self.n:
                cat_inputs = torch.cat(inputs, dim=1)
                return self.nodeop[id](cat_inputs)
            else:
                results[id] = self.nodeop[id](*inputs)

            # 删除前驱结点result中，不再需要的result
            for pred in self.G.predecessors(id):  # 获得节点的所有前驱结点
                succs = list(self.G.successors(pred))  # 获得每个前驱结点的所有后继节点
                # 如果排名最后的后继节点是当前节点，说明该前驱结点的result不再被后续的节点需要，可以删除
                if max(succs) == id:
                    del results[pred]



class ComplexNet(nn.Sequential):
    """
    Neural Network based on complex network

    Parameters:
    -----------
    Gs  :  a list of `NetworkX DiGraph` objects
    ns  :  number of channels of all stages
    Unit :
    c_out : number of output channels
    kwargs : additional args to Unit class
    """
    def __init__(self, Gs:list, ns:list, Unit:nn.Module, c_out:int=10, **kwargs):
        super(ComplexNet, self).__init__()
        stem = conv_bn(3, ns[0])
        network_ops = []
        for i in range(len(ns)-2):
            network_ops += [NetworkOP(Gs[i], ns[i], ns[i+1], Unit, stride=2, **kwargs)]
        network_ops += [NetworkOP(Gs[-1], ns[-2], ns[-1], Unit, stride=1, **kwargs)]

        classifier = Classifier(ns[-1], c_out)
        super().__init__(
            stem,
            *network_ops,
            classifier
        )
        init_cnn(self)

def complexnet_32():
    species = [50,100,200,200]
    connectance = [0.05]*4
    Gs = [after_DAG(niche(s, c)[1]) for s,c in zip(species, connectance)]
    ns = [32,32,32,32,32]
    model = ComplexNet(Gs, ns, xception)
    return model